{% extends "base.html" %}
{% block main %}
<div id="app">
  <h1 class="text-4xl">Account<span v-if="account.id">: {{account.name}}</span></h1>
  <table v-if="account.transactions">
    <tr>
      <th class="text-left pr-2">Date</th>
      <th class="text-left pr-2">Memo / Accounts</th>
      <th class="text-left pr-2" colspan="3">Entries
        {% include "components/button-plus.html" %}
      </th>
    </tr>
    <!-- new transaction -->
    <!-- first line includes date, memo, and first entry for this page's account. -->
    <tr v-for="(entry, index) in newTransaction.entries">
      <template v-if="index == 0">
        <td class="align-text-top pt-1 pr-2">
          <input type="date" v-model="newTransaction.effective" />
        </td>
        <td class="align-text-top pt-1 pr-2">
          <input type="text" class="w-48 border rounded" v-model="newTransaction.memo" />
        </td>
      </template>
      <template v-else="">
        <td></td>
        <td class="align-text-top pr-2">
          <select class="w-44 ml-4" v-model="newTransaction.entries[index].acct">
            <option value=""></option>
            <option v-for="acct of accounts" :value="acct.id" v-text="acct.name"></option>
          </select>
        </td>
      </template>
      <td class="align-text-top pt-1 pr-2">
        <input class="border rounded w-16" type="text" pattern="\d+(\.\d*)?"
          :OFF-disabled="newTransaction.entries[index].cr != null"
          v-model="newTransaction.entries[index].dr" @change="balanceNewTransaction" />
      </td>
      <td class="align-text-top pt-1 pr-2">
        <input class="border rounded w-16" type="text" pattern="\d+(\.\d*)?"
          :OFF-disabled="newTransaction.entries[index].dr != null"
          v-model="newTransaction.entries[index].cr" @change="balanceNewTransaction" />
      </td>
      <td class="align-text-top pt-1 pr-2">
        <select v-model="newTransaction.entries[index].curr" @change="balanceNewTransaction">
          <option value=""></option>
          <template v-for="currency of currencies">
            <option v-if="entry.curr == currency.code" :value="currency.code" v-text="currency.code"
              selected="">
            <option v-else="" :value="currency.code" v-text="currency.code">
          </template>
          </option>
        </select>
      </td>
    </tr>
    <tr>
      <td class="align-text-top pr-2 text-right" colspan="5">
        <button class="pr-2">Post</button>
        <button>Cancel</button>
      </td>
    </tr>
    <!-- existing transactions -->
    <template v-for="transaction in account.transactions">
      <!-- entries for this account first since we're suppressing this account name on the page -->
      <tr v-for="(entry, entryIndex) in transaction.entries.filter(
          (entry) => entry.acct == account.id).concat(
            transaction.entries.filter((entry) => entry.acct != account.id))">
        <template v-if="entryIndex == 0">
          <td class="align-text-top pt-1 pr-2">{{transaction.effective.split('T')[0]}}</td>
          <td class="align-text-top pt-1 pr-2"><span class="font-bold">{{transaction.memo}}</span>
          </td>
        </template>
        <template v-else="">
          <td class="align-text-top pt-1 pr-2"></td>
          <td class="align-text-top pt-1 pr-2">
            <a v-if="entry.acct != account.id" class="ml-4"
              :href="`/{$tenant_id}/accounts/view?id=${entry.acct}`">
              {{entry.acct_name}}
            </a>
          </td>
        </template>
        <td class="align-text-top pt-1 pr-2">
          <span :class="entry.acct == account.id ? 'font-bold' : ''">{{entry.dr}}</span>
        </td>
        <td class="align-text-top pt-1 pr-2">
          <span :class="entry.acct == account.id ? 'font-bold' : ''">{{entry.cr}}</span>
        </td>
        <td class="align-text-top pt-1 pr-2">
          <span :class="entry.acct == account.id ? 'font-bold' : ''">{{entry.curr}}</span>
        </td>
      </tr>
    </template>
  </table>
</div>
{% endblock %}
{% block footscript %}
<script>
  const TENANT = "{$tenant_id}";
  const ACCOUNT_ID = "{$request.query_params.get('id')}";
  // create an integer sequence generator - used to ensure that entries have unique keys
  function integerSequence() {
    var id = 0;
    return () => id += 1;
  }
  const newEntryKey = integerSequence();
  const app = Vue.createApp({
    data() {
      return {
        error: null,
        account: {},
        currencies: [],
        accounts: [],
        newTransaction: {
          // tenant_id: TENANT,
          effective: (new Date()).toISOString().split('T')[0],
          memo: "",
          entries: [
            // the first entry is assigned to this page's account
            {
              key: newEntryKey(),
              // tenant_id: TENANT,
              acct: ACCOUNT_ID,
              ref: null,
              dr: null,
              cr: null,
              curr: null,
            },
          ]
        }
      }
    },
    async created() {
      this.account = await fetchAccount();
      this.accounts = await fetchAccounts();
      this.currencies = await fetchCurrencies();
    },
    methods: {
      // when a new transaction entry is changed, balance the new transaction
      balanceNewTransaction(event) {
        var balances = {};
        var entriesByKey = {};

        // propagate entry changes and calculate balances
        for (entry of this.newTransaction.entries) {
          // add the entry to the entriesByKey mapping
          entriesByKey[entry.key] = entry;

          // propagate change from the ref entry to this one
          if (entry.ref) {
            const refEntry = entriesByKey[entry.ref];
            console.log("refEntry =", refEntry)
            entry.curr = refEntry.curr;
            if (!refEntry.cr && !refEntry.dr) {
              entry.cr = null;
              entry.dr = null;
            }
          }

          // calculate balance changes
          if (entry.dr || entry.cr) {
            if (!balances[entry.curr]) {
              balances[entry.curr] = {dr:0, cr:0, curr:entry.curr, refs:[]}
            }
            balances[entry.curr].dr += Number(entry.dr)
            balances[entry.curr].cr += Number(entry.cr)
            balances[entry.curr].refs.push(entry.key)
          }
        }
        console.log(JSON.stringify(balances))

        // keep entries that are not null or don't have a ref (first doesn't, others do)
        this.newTransaction.entries = this.newTransaction.entries.filter(
          entry => entry.dr || entry.cr || !entry.ref);

        // add entries to balance the transaction -- by currency
        for ([curr, bal] of Object.entries(balances)) {
          if (bal.dr > bal.cr) {
            var newEntry = {dr:null, cr:bal.dr - bal.cr}
          } else if (bal.cr > bal.dr) {
            var newEntry = {dr:bal.cr - bal.dr, cr:null}
          }

          if (newEntry) {
            newEntry.curr = curr
            newEntry.ref = bal.refs[bal.refs.length - 1]
            this.newTransaction.entries.push(newEntry)
          }
        }
      }
    }
  }).mount("#app");
  async function fetchAccount() {
    const account_url = `http://localhost:8000/api/accounts?id=${ACCOUNT_ID}`;
    const result = await fetch(account_url).then((response) => response.json());
    if (result.length > 0) {
      const tx_url = `http://localhost:8000/api/transactions?acct=${ACCOUNT_ID}&_orderby=-id`;
      account = result[0];
      account.transactions = await fetch(tx_url).then((response) => response.json());
      return account;
    } else {
      return {};
    }
  }
  async function fetchCurrencies() {
    const currencies_url = "http://localhost:8000/api/currencies?_orderby=code";
    return await fetch(currencies_url).then((response) => response.json());
  }
  async function fetchAccounts() {
    const accounts_url = `http://localhost:8000/api/accounts?tenant=${TENANT}&_orderby=parent_id,name`;
    accounts = await fetch(accounts_url).then((response) => response.json());
    return accounts
  }
</script>
{% endblock %}