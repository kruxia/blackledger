{% extends "base.html" %}
{% block main %}
<div id="app">
  <h1 class="text-4xl">Account<span v-if="account.id">: {{account.name}}</span></h1>
  <form @submit.prevent="submitNewTransaction">
    <table>
      <tr>
        <th class="text-left pr-2">Date</th>
        <th class="text-left pr-2">Memo / Accounts</th>
        <th class="text-left pr-2" colspan="3">Entries</th>
      </tr>
      <!-- new transaction
      first line includes date, memo, and first entry for this page's account.
      following lines for following entries
    -->
      <tr v-for="(entry, index) in newTransaction.entries">
        <template v-if="index == 0">
          <td class="align-text-top pt-1 pr-2">
            <input id="new-tx-date" type="date" v-model="newTransaction.effective" />
          </td>
          <td class="align-text-top pt-1 pr-2">
            <input id="new-tx-memo" type="text" class="w-48 border rounded"
              v-model="newTransaction.memo" />
          </td>
        </template>
        <template v-else="">
          <td></td>
          <td class="align-text-top pr-2">
            <select class="w-44 ml-4" v-model="newTransaction.entries[index].acct">
              <option value=""></option>
              <option v-for="acct of accounts" :value="acct.id" v-text="acct.name"></option>
            </select>
          </td>
        </template>
        <td class="align-text-top pt-1 pr-2">
          <input class="border rounded w-16" type="text" pattern="\d+(\.\d*)?"
            v-model="newTransaction.entries[index].dr" @change="balanceNewTransaction" />
        </td>
        <td class="align-text-top pt-1 pr-2">
          <input class="border rounded w-16" type="text" pattern="\d+(\.\d*)?"
            v-model="newTransaction.entries[index].cr" @change="balanceNewTransaction" />
        </td>
        <td class="align-text-top pt-1 pr-2">
          <select class="w-12" v-model="newTransaction.entries[index].curr"
            @change="balanceNewTransaction">
            <option value=""></option>
            <option v-for="currency of currencies" :value="currency.code" v-text="currency.code">
            </option>
          </select>
        </td>
      </tr>
      <tr>
        <td class="align-text-top pr-2 text-right" colspan="5">
          <input type="submit" class="pr-2" value="Post" />
          <button @click.prevent="resetNewTransaction">Cancel</button>
        </td>
      </tr>
      <!-- existing transactions -->
      <template v-for="transaction in transactions">
        <!-- entries for this account first since we're suppressing this account name on the page -->
        <tr v-for="(entry, entryIndex) in transaction.entries.filter(
          (entry) => entry.acct == account.id).concat(
            transaction.entries.filter((entry) => entry.acct != account.id))">
          <template v-if="entryIndex == 0">
            <td class="align-text-top pt-1 pr-2">{{transaction.effective.split('T')[0]}}</td>
            <td class="align-text-top pt-1 pr-2"><span class="font-bold">{{transaction.memo}}</span>
            </td>
          </template>
          <template v-else="">
            <td class="align-text-top pt-1 pr-2"></td>
            <td class="align-text-top pt-1 pr-2">
              <a v-if="entry.acct != account.id" class="ml-4"
                :href="`/{$tenant_id}/accounts/view?id=${entry.acct}`">
                {{entry.acct_name}}
              </a>
            </td>
          </template>
          <td class="align-text-top pt-1 pr-2">
            <span :class="entry.acct == account.id ? 'font-bold' : ''">{{entry.dr}}</span>
          </td>
          <td class="align-text-top pt-1 pr-2">
            <span :class="entry.acct == account.id ? 'font-bold' : ''">{{entry.cr}}</span>
          </td>
          <td class="align-text-top pt-1 pr-2">
            <span :class="entry.acct == account.id ? 'font-bold' : ''">{{entry.curr}}</span>
          </td>
        </tr>
      </template>
    </table>
  </form>
</div>
{% endblock %}
{% block footscript %}
<script>
  const TENANT_ID = "{$tenant_id}";
  const ACCOUNT_ID = "{$request.query_params.get('id')}";
  // create an integer sequence generator - used to ensure that entries have unique keys
  function integerSequence() {
    var id = 0;
    return () => id += 1;
  }
  const newEntryKey = integerSequence();
  const app = Vue.createApp({
    data() {
      return {
        error: null,
        account: {},
        currencies: [],
        accounts: [],
        newTransaction: newBlankTransaction(),
        transactions: [],
      }
    },
    async created() {
      this.account = await fetchAccount(ACCOUNT_ID);
      this.accounts = await fetchAccounts();
      this.currencies = await fetchCurrencies();
      this.transactions = await fetchTransactions(ACCOUNT_ID);
      document.getElementById('new-tx-memo').focus();
    },
    methods: {
      balanceNewTransaction(event) {
        console.log(JSON.stringify(this.newTransaction, null, 2));
        var balances = {};
        for (index in this.newTransaction.entries) {
          entry = this.newTransaction.entries[index];
          if (index > 0 && !entry.dr && !entry.cr) {
            // remove empty non-initial entry #1 (see #2 below)
            this.newTransaction.entries.pop(entry);
          } else {
            // update entry.curr to match entry.ref
            if (entry.ref) {
              entry.curr = this.newTransaction.entries[entry.ref].curr;
            }
            // update the balances
            balances = Object.assign(balances, {
              [entry.curr]: {
                dr: Number((balances[entry.curr] || { dr: 0 }).dr) + Number(entry.dr),
                cr: Number((balances[entry.curr] || { cr: 0 }).cr) + Number(entry.cr),
                refs: (balances[entry.curr] || { refs: [] }).refs.concat([index]),
              }
            });
          }
        }
        console.log(JSON.stringify(balances, null, 2));

        // remove empty non-initial entries #2 (see #1 above)
        this.newTransaction.entries = this.newTransaction.entries.filter(
          (entry, index) => index == 0 || entry.dr || entry.cr);

        // add entries to balance the transaction
        for (curr in balances) {
          var bal = balances[curr];
          if (bal.dr > bal.cr) {
            this.newTransaction.entries.push(newEntry({
              cr: (bal.dr - bal.cr).toString(), curr: curr, ref: bal.refs.slice(-1)
            }));
          } else if (bal.cr > bal.dr) {
            this.newTransaction.entries.push(newEntry({
              dr: (bal.cr - bal.dr).toString(), curr: curr, ref: bal.refs.slice(-1)
            }));
          }
        }
      },
      async submitNewTransaction(event) {
        const transaction_url = `http://localhost:8000/api/transactions`;
        console.log(JSON.stringify(this.newTransaction, null, 2))
        const fetchOptions = {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(this.newTransaction)
        }
        const result = await fetch(transaction_url, fetchOptions).then(
          async function (response) {
            const transaction = await response.json();
            const accountsById = Object.fromEntries(
              app.accounts.map(acct => [acct.id, acct]));
            if (response.status == 201) {
              for (entry of transaction.entries) {
                entry.acct_name = accountsById[entry.acct].name;
              }
              // transaction == the new transaction
              app.transactions.unshift(transaction);
              // clear the newTransaction
              app.resetNewTransaction(event);
            }
            return { "status": response.status, "data": transaction };
          });
        console.log(JSON.stringify(result, null, 2))
      },

      resetNewTransaction(event) {
        this.newTransaction = newBlankTransaction();
        document.getElementById('new-tx-memo').focus();
      }
    },
  }).mount("#app");

  function newEntry(params) {
    return Object.assign({
      key: newEntryKey(),
      tenant_id: TENANT_ID,
      acct: null,
      dr: null,
      cr: null,
      curr: null
    }, params);
  }
  function newBlankTransaction() {
    return {
      tenant_id: TENANT_ID,
      effective: (new Date()).toISOString().split('T')[0],
      memo: "",
      entries: [
        // the first entry is assigned to this page's account
        newEntry({ acct: ACCOUNT_ID }),
      ]
    }
  }
  async function fetchAccount(account_id) {
    const account_url = `http://localhost:8000/api/accounts?id=${account_id}`;
    const result = await fetch(account_url).then((response) => response.json());
    if (result.length > 0) {
      account = result[0];
      return account;
    } else {
      return {};
    }
  }
  async function fetchTransactions(account_id) {
    const tx_url = `http://localhost:8000/api/transactions?acct=${account_id}&_orderby=-id`;
    return await fetch(tx_url).then((response) => response.json());
  }
  async function fetchCurrencies() {
    const currencies_url = "http://localhost:8000/api/currencies?_orderby=code";
    return await fetch(currencies_url).then((response) => response.json());
  }
  async function fetchAccounts() {
    const accounts_url = `http://localhost:8000/api/accounts?tenant=${TENANT_ID}&_orderby=parent_id,name`;
    accounts = await fetch(accounts_url).then((response) => response.json());
    return accounts
  }
</script>
{% endblock %}